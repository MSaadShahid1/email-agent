#!/usr/bin/env python3
"""
Universal UI Agent System
A robust agent that can perform tasks across multiple web services with different UI layouts.

Features:
- Natural language instruction parsing
- Multi-provider support (Gmail, Outlook)
- Robust error handling and recovery
- Comprehensive logging
- Secure session management
- Modular architecture

Requirements:
    pip install playwright openai python-dotenv
    python -m playwright install

Usage:
    python agent.py "send email to alice@example.com saying 'Meeting at 2pm tomorrow'"
    python agent.py "send email to bob@test.com about project update" --provider gmail
"""

import re
import time
import json
import os
import logging
import argparse
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Dict, List, Optional, Any, Tuple
from enum import Enum
from pathlib import Path
import asyncio

from playwright.async_api import async_playwright, Page, Browser, BrowserContext, TimeoutError as PlaywrightTimeoutError

# Configuration Constants
DEFAULT_TIMEOUT = 30000
DEFAULT_RETRY_COUNT = 3
COOKIE_FILE = "session_cookies.json"
LOG_FILE = "agent.log"

class TaskType(Enum):
    SEND_EMAIL = "send_email"
    UNKNOWN = "unknown"

class Severity(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class EmailIntent:
    """Structured representation of email intent"""
    recipient: str
    subject: str
    body: str
    task_type: TaskType = TaskType.SEND_EMAIL
    
    def is_valid(self) -> bool:
        return bool(self.recipient and self.body)

@dataclass
class ActionStep:
    """Represents a single UI interaction step"""
    action: str  # click, fill, wait, verify
    target: str  # selector key or element description
    value: Optional[str] = None
    timeout: int = DEFAULT_TIMEOUT
    retries: int = DEFAULT_RETRY_COUNT

class Logger:
    """Enhanced logging system with multiple levels"""
    
    def __init__(self, log_file: str = LOG_FILE):
        self.steps = []
        self.setup_logging(log_file)
    
    def setup_logging(self, log_file: str):
        """Setup file and console logging"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def log(self, message: str, severity: Severity = Severity.LOW):
        """Log message with severity level"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        entry = f"[{timestamp}] {message}"
        self.steps.append(entry)
        
        if severity == Severity.CRITICAL:
            self.logger.error(message)
        elif severity == Severity.HIGH:
            self.logger.warning(message)
        else:
            self.logger.info(message)
    
    def dump_steps(self) -> List[str]:
        """Return all logged steps"""
        return self.steps.copy()

class InstructionParser:
    """LLM-like instruction parser (mocked for reliability)"""
    
    @staticmethod
    def parse_email_instruction(text: str) -> EmailIntent:
        """Parse natural language into structured email intent"""
        text_lower = text.lower()
        
        # Extract email address
        email_pattern = r'([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})'
        email_match = re.search(email_pattern, text)
        recipient = email_match.group(1) if email_match else ""
        
        # Extract message content
        body = ""
        subject = ""
        
        # Look for quoted content
        quote_patterns = [
            r"saying\s+[\"'](.+?)[\"']",
            r"message\s+[\"'](.+?)[\"']",
            r"text\s+[\"'](.+?)[\"']"
        ]
        
        for pattern in quote_patterns:
            match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)
            if match:
                body = match.group(1).strip()
                break
        
        # Look for subject keywords
        subject_patterns = [
            r"about\s+(.+?)(?:\s+saying|\s+with|\s*$)",
            r"regarding\s+(.+?)(?:\s+saying|\s+with|\s*$)",
            r"re:\s*(.+?)(?:\s+saying|\s+with|\s*$)"
        ]
        
        for pattern in subject_patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                subject = match.group(1).strip()
                break
        
        # Generate subject from body if not found
        if not subject and body:
            words = re.findall(r'\w+', body)
            subject = " ".join(words[:6]) + ("..." if len(words) > 6 else "")
        
        # Use fallback content if nothing found
        if not body:
            if subject:
                body = f"Subject: {subject}\n\n(Generated by automation agent)"
            else:
                body = "Automated message from UI agent"
                subject = "Automated Message"
        
        return EmailIntent(
            recipient=recipient,
            subject=subject,
            body=body,
            task_type=TaskType.SEND_EMAIL
        )

class BaseProvider(ABC):
    """Abstract base class for service providers"""
    
    def __init__(self, name: str, logger: Logger):
        self.name = name
        self.logger = logger
        self.selectors = self._get_selectors()
        self.base_url = self._get_base_url()
    
    @abstractmethod
    def _get_selectors(self) -> Dict[str, List[str]]:
        """Return provider-specific selectors"""
        pass
    
    @abstractmethod
    def _get_base_url(self) -> str:
        """Return provider base URL"""
        pass
    
    @abstractmethod
    def get_login_url_pattern(self) -> str:
        """Return URL pattern to detect successful login"""
        pass
    
    def get_action_plan(self, intent: EmailIntent) -> List[ActionStep]:
        """Generate action plan for email sending"""
        return [
            ActionStep("click", "compose_button"),
            ActionStep("wait", "page_load", timeout=5000),
            ActionStep("fill", "to_field", intent.recipient),
            ActionStep("wait", "field_update", timeout=2000),
            ActionStep("fill", "subject_field", intent.subject),
            ActionStep("wait", "field_update", timeout=2000),
            ActionStep("fill", "body_field", intent.body),
            ActionStep("wait", "field_update", timeout=3000),
            ActionStep("click", "send_button"),
            ActionStep("verify", "send_confirmation", timeout=10000)
        ]

class GmailProvider(BaseProvider):
    """Gmail-specific provider implementation"""
    
    def __init__(self, logger: Logger):
        super().__init__("Gmail", logger)
    
    def _get_selectors(self) -> Dict[str, List[str]]:
        return {
            "compose_button": [
                "div[role='button'][gh='cm']",
                "//div[contains(text(), 'Compose') and @role='button']",
                "//div[@aria-label='Compose']",
                ".T-I.T-I-KE.L3"
            ],
            "to_field": [
                "textarea[name='to']",
                "//textarea[contains(@aria-label,'To')]",
                "//input[@name='to']",
                ".vR .vT"
            ],
            "subject_field": [
                "input[name='subjectbox']",
                "//input[contains(@placeholder,'Subject')]",
                "//input[@name='subject']",
                ".aoT"
            ],
            "body_field": [
                "div[aria-label='Message Body']",
                "//div[@aria-label and contains(translate(@aria-label,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'message')]",
                "//div[@contenteditable='true' and contains(@aria-label,'Message')]",
                ".Am .Al.editable"
            ],
            "send_button": [
                "div[aria-label*='Send']",
                "//div[contains(@aria-label,'Send')]",
                "//div[contains(text(), 'Send') and @role='button']",
                ".T-I.J-J5-Ji.aoO.v7.T-I-atl.L3"
            ],
            "send_confirmation": [
                "//div[contains(text(), 'Message sent')]",
                "//span[contains(text(), 'Message sent')]",
                ".aS .aT"
            ]
        }
    
    def _get_base_url(self) -> str:
        return "https://mail.google.com/"
    
    def get_login_url_pattern(self) -> str:
        return "**/mail/u/**"

class OutlookProvider(BaseProvider):
    """Outlook Web-specific provider implementation"""
    
    def __init__(self, logger: Logger):
        super().__init__("Outlook", logger)
    
    def _get_selectors(self) -> Dict[str, List[str]]:
        return {
            "compose_button": [
                "button[aria-label='New mail']",
                "button[title='New mail']",
                "//button[contains(.,'New mail') and not(contains(.,'chat'))]",
                "//button[@aria-label='New mail' or @title='New mail']",
                "[data-testid='new-mail-button']",
                "button[name='New Mail']"
            ],
            "to_field": [
                "input[aria-label='To']",
                "input[aria-describedby*='To']",
                "//input[contains(@aria-label,'To')]",
                "//input[contains(@placeholder,'Start typing a name')]",
                ".ms-BasePicker-input",
                "[data-testid='To'] input",
                "div[aria-label='To'] input"
            ],
            "subject_field": [
                "input[aria-label='Subject']",
                "input[aria-describedby*='Subject']",
                "//input[contains(@aria-label,'Subject')]",
                "//input[contains(@placeholder,'Add a subject')]",
                "[data-testid='Subject'] input",
                "input[name='Subject']"
            ],
            "body_field": [
                "div[aria-label='Message body, press Alt+F10 to exit']",
                "div[data-testid='mail-compose-body']",
                "//div[@contenteditable='true' and contains(@aria-label,'Message body')]",
                ".rps_1fb8 [contenteditable='true']",
                "[role='textbox'][contenteditable='true']",
                ".allowTextSelection[contenteditable='true']"
            ],
            "send_button": [
                "button[aria-label='Send']",
                "button[title='Send']",
                "//button[contains(.,'Send') and not(contains(.,'Cancel')) and not(contains(.,'Discard'))]",
                "[data-testid='mail-compose-send-button']",
                "button[name='Send']"
            ],
            "send_confirmation": [
                "//div[contains(text(), 'sent')]",
                "//span[contains(text(), 'sent')]",
                ".ms-MessageBar",
                "[data-testid='mail-sent-confirmation']"
            ]
        }
    
    def _get_base_url(self) -> str:
        return "https://outlook.office.com/mail/"
    
    def get_login_url_pattern(self) -> str:
        return "**/mail/**"

class SessionManager:
    """Secure session and cookie management"""
    
    def __init__(self, cookie_file: str = COOKIE_FILE, logger: Optional[Logger] = None):
        self.cookie_file = Path(cookie_file)
        self.logger = logger or Logger()
    
    async def save_session(self, context: BrowserContext, domains: List[str]):
        """Save cookies for specified domains"""
        try:
            cookies = []
            for domain in domains:
                domain_cookies = await context.cookies([domain])
                cookies.extend(domain_cookies)
            
            # Simple encryption could be added here
            with open(self.cookie_file, 'w') as f:
                json.dump(cookies, f, indent=2)
            
            self.logger.log(f"Saved session cookies for {len(domains)} domains")
        except Exception as e:
            self.logger.log(f"Failed to save session: {e}", Severity.HIGH)
    
    async def load_session(self, context: BrowserContext) -> bool:
        """Load saved cookies"""
        try:
            if not self.cookie_file.exists():
                return False
            
            with open(self.cookie_file, 'r') as f:
                cookies = json.load(f)
            
            if cookies:
                await context.add_cookies(cookies)
                self.logger.log(f"Loaded {len(cookies)} session cookies")
                return True
            
        except Exception as e:
            self.logger.log(f"Failed to load session: {e}", Severity.MEDIUM)
        
        return False
    
    def clear_session(self):
        """Clear saved session"""
        try:
            if self.cookie_file.exists():
                self.cookie_file.unlink()
                self.logger.log("Cleared session cookies")
        except Exception as e:
            self.logger.log(f"Failed to clear session: {e}", Severity.LOW)

class UIInteractor:
    """Handles all browser UI interactions with robust error handling"""
    
    def __init__(self, logger: Logger):
        self.logger = logger
    
    async def wait_for_element(self, page: Page, selectors: List[str], timeout: int = DEFAULT_TIMEOUT) -> Optional[str]:
        """Wait for any of the selectors to be available and return the working selector"""
        for selector in selectors:
            try:
                locator = page.locator(selector)
                await locator.first.wait_for(state="visible", timeout=timeout)
                if await locator.count() > 0:
                    return selector
            except PlaywrightTimeoutError:
                continue
            except Exception as e:
                self.logger.log(f"Error checking selector {selector}: {e}", Severity.LOW)
        return None
    
    async def safe_click(self, page: Page, selectors: List[str], retries: int = DEFAULT_RETRY_COUNT) -> bool:
        """Safely click element with retries"""
        for attempt in range(retries):
            working_selector = await self.wait_for_element(page, selectors)
            if not working_selector:
                self.logger.log(f"No clickable element found (attempt {attempt + 1}/{retries})", Severity.MEDIUM)
                await asyncio.sleep(2)
                continue
            
            try:
                locator = page.locator(working_selector)
                
                # Ensure element is clickable
                await locator.first.scroll_into_view_if_needed()
                await locator.first.wait_for(state="visible", timeout=10000)
                
                # Try click with different methods
                try:
                    await locator.first.click(timeout=10000)
                except:
                    # Force click if normal click fails
                    await locator.first.click(force=True)
                
                self.logger.log(f"Successfully clicked: {working_selector}")
                return True
                
            except Exception as e:
                self.logger.log(f"Click failed for {working_selector} (attempt {attempt + 1}): {e}", Severity.MEDIUM)
                await asyncio.sleep(2)
        
        return False
    
    async def safe_fill(self, page: Page, selectors: List[str], value: str, retries: int = DEFAULT_RETRY_COUNT) -> bool:
        """Safely fill element with retries - special handling for Outlook email fields"""
        for attempt in range(retries):
            working_selector = await self.wait_for_element(page, selectors)
            if not working_selector:
                self.logger.log(f"No fillable element found (attempt {attempt + 1}/{retries})", Severity.MEDIUM)
                await asyncio.sleep(2)
                continue
            
            try:
                locator = page.locator(working_selector)
                await locator.first.scroll_into_view_if_needed()
                
                # Special handling for email recipient fields (Outlook autocomplete)
                if "To" in str(selectors) or "to_field" in str(selectors):
                    await self._fill_email_field(page, locator, value)
                else:
                    # Regular field handling
                    await locator.first.clear()
                    
                    try:
                        await locator.first.fill(value, timeout=10000)
                    except:
                        # Fallback to typing
                        await locator.first.type(value, delay=50)
                
                self.logger.log(f"Successfully filled: {working_selector} with '{value[:50]}'")
                return True
                
            except Exception as e:
                self.logger.log(f"Fill failed for {working_selector} (attempt {attempt + 1}): {e}", Severity.MEDIUM)
                await asyncio.sleep(2)
        
        return False
    
    async def _fill_email_field(self, page: Page, locator, email: str):
        """Special handling for email recipient fields with autocomplete"""
        try:
            # Clear any existing content
            await locator.first.clear()
            
            # Type the email address slowly to trigger autocomplete
            await locator.first.type(email, delay=100)
            
            # Wait a moment for autocomplete suggestions
            await asyncio.sleep(1500)
            
            # Press Tab or Enter to accept the email (common patterns)
            try:
                # First try Tab to accept autocomplete
                await page.keyboard.press("Tab")
                await asyncio.sleep(500)
                
                # Check if email was accepted, if not try Enter
                current_value = await locator.first.input_value()
                if email not in current_value:
                    await page.keyboard.press("Enter")
                    await asyncio.sleep(500)
                
                # If still not accepted, try clicking away and back
                if email not in current_value:
                    await page.keyboard.press("Escape")  # Close any dropdowns
                    await asyncio.sleep(300)
                    await locator.first.click()
                    await locator.first.fill(email)
                    await page.keyboard.press("Enter")
                
            except Exception as e:
                self.logger.log(f"Email field acceptance failed: {e}", Severity.MEDIUM)
                
        except Exception as e:
            self.logger.log(f"Email field special handling failed: {e}", Severity.MEDIUM)
            # Fallback to regular fill
            await locator.first.fill(email)
    
    async def verify_action(self, page: Page, selectors: List[str], timeout: int = 10000) -> bool:
        """Verify an action completed by checking for confirmation elements"""
        working_selector = await self.wait_for_element(page, selectors, timeout)
        if working_selector:
            self.logger.log("Action verification successful")
            return True
        else:
            self.logger.log("Action verification failed", Severity.MEDIUM)
            return False

class UniversalUIAgent:
    """Main agent class that orchestrates the automation"""
    
    def __init__(self, provider_name: str = "gmail", headless: bool = True):
        self.logger = Logger()
        self.session_manager = SessionManager(logger=self.logger)
        self.interactor = UIInteractor(self.logger)
        self.headless = headless
        
        # Initialize provider
        providers = {
            "gmail": GmailProvider,
            "outlook": OutlookProvider
        }
        
        if provider_name not in providers:
            raise ValueError(f"Unsupported provider: {provider_name}. Available: {list(providers.keys())}")
        
        self.provider = providers[provider_name](self.logger)
        self.logger.log(f"Initialized agent with {self.provider.name} provider")
    
    async def authenticate(self, page: Page) -> bool:
        """Handle authentication process"""
        self.logger.log("Starting authentication process...")
        
        try:
            # Wait for login or redirect to main interface
            await page.wait_for_url(self.provider.get_login_url_pattern(), timeout=90000)
            self.logger.log("Authentication successful - reached main interface")
            return True
            
        except PlaywrightTimeoutError:
            self.logger.log("Authentication timeout - manual intervention may be required", Severity.HIGH)
            return False
        except Exception as e:
            self.logger.log(f"Authentication error: {e}", Severity.HIGH)
            return False
    
    async def execute_task(self, intent: EmailIntent) -> bool:
        """Execute the main task automation"""
        if not intent.is_valid():
            self.logger.log("Invalid intent provided", Severity.CRITICAL)
            return False
        
        self.logger.log(f"Executing task: Send email to {intent.recipient}")
        
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=self.headless)
            context = await browser.new_context()
            page = await context.new_page()
            
            # Setup page event handlers
            page.on("console", lambda msg: self.logger.log(f"Browser console: {msg.text}"))
            page.on("dialog", lambda dialog: asyncio.create_task(dialog.accept()))
            
            try:
                # Load existing session or navigate fresh
                session_loaded = await self.session_manager.load_session(context)
                
                await page.goto(self.provider.base_url, timeout=60000)
                await page.wait_for_load_state("networkidle", timeout=30000)
                
                # Handle authentication if needed
                if not session_loaded or not await self._check_authenticated(page):
                    self.logger.log("Authentication required")
                    authenticated = await self.authenticate(page)
                    
                    if not authenticated:
                        self.logger.log("Manual login required. Please complete authentication.", Severity.HIGH)
                        input("Press Enter after completing authentication...")
                        await page.wait_for_url(self.provider.get_login_url_pattern(), timeout=90000)
                    
                    # Save session after successful authentication
                    domains = [self.provider.base_url]
                    await self.session_manager.save_session(context, domains)
                
                # Execute email sending workflow
                success = await self._execute_email_workflow(page, intent)
                
                if success:
                    self.logger.log("Task completed successfully!")
                else:
                    self.logger.log("Task failed to complete", Severity.HIGH)
                
                # Take final screenshot
                await page.screenshot(path=f"final_result_{self.provider.name.lower()}.png", full_page=True)
                
                return success
                
            except Exception as e:
                self.logger.log(f"Task execution failed: {e}", Severity.CRITICAL)
                return False
            
            finally:
                await browser.close()
    
    async def _check_authenticated(self, page: Page) -> bool:
        """Check if already authenticated"""
        try:
            current_url = page.url
            return self.provider.get_login_url_pattern().replace("**/", "").replace("**", "") in current_url
        except:
            return False
    
    async def _execute_email_workflow(self, page: Page, intent: EmailIntent) -> bool:
        """Execute the email sending workflow"""
        action_plan = self.provider.get_action_plan(intent)
        
        for i, step in enumerate(action_plan):
            self.logger.log(f"Step {i+1}/{len(action_plan)}: {step.action} {step.target}")
            
            success = False
            
            if step.action == "click":
                if step.target in self.provider.selectors:
                    success = await self.interactor.safe_click(
                        page, self.provider.selectors[step.target], step.retries
                    )
                else:
                    self.logger.log(f"Unknown target: {step.target}", Severity.HIGH)
            
            elif step.action == "fill":
                if step.target in self.provider.selectors and step.value:
                    success = await self.interactor.safe_fill(
                        page, self.provider.selectors[step.target], step.value, step.retries
                    )
                else:
                    self.logger.log(f"Invalid fill step: {step.target}", Severity.HIGH)
            
            elif step.action == "wait":
                await asyncio.sleep(step.timeout / 1000)
                success = True
            
            elif step.action == "verify":
                if step.target in self.provider.selectors:
                    success = await self.interactor.verify_action(
                        page, self.provider.selectors[step.target], step.timeout
                    )
                else:
                    self.logger.log(f"Unknown verification target: {step.target}", Severity.MEDIUM)
                    success = True  # Don't fail on verification issues
            
            if not success and step.action in ["click", "fill"]:
                self.logger.log(f"Critical step failed: {step.action} {step.target}", Severity.HIGH)
                return False
            
            # Small delay between steps
            await asyncio.sleep(1)
        
        return True

async def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(description="Universal UI Agent - Automate tasks across web services")
    parser.add_argument("instruction", type=str, help="Natural language instruction (e.g., 'send email to alice@example.com saying hello')")
    parser.add_argument("--provider", choices=["gmail", "outlook"], default="gmail", help="Service provider to use")
    parser.add_argument("--headless", action="store_true", help="Run browser in headless mode")
    parser.add_argument("--clear-session", action="store_true", help="Clear saved session before running")
    
    args = parser.parse_args()
    
    # Parse the instruction
    intent = InstructionParser.parse_email_instruction(args.instruction)
    
    if not intent.is_valid():
        print("❌ Could not parse instruction. Please provide recipient and message content.")
        print("Example: 'send email to alice@example.com saying hello world'")
        return
    
    print(f"📧 Parsed instruction:")
    print(f"   To: {intent.recipient}")
    print(f"   Subject: {intent.subject}")
    print(f"   Body: {intent.body[:100]}{'...' if len(intent.body) > 100 else ''}")
    print(f"   Provider: {args.provider}")
    print()
    
    # Clear session if requested
    if args.clear_session:
        session_manager = SessionManager()
        session_manager.clear_session()
        print("🧹 Cleared existing session")
    
    # Create and run agent
    agent = UniversalUIAgent(provider_name=args.provider, headless=args.headless)
    
    print("🚀 Starting automation...")
    success = await agent.execute_task(intent)
    
    if success:
        print("✅ Task completed successfully!")
    else:
        print("❌ Task failed. Check logs for details.")
    
    # Show execution summary
    print("\n📊 Execution Summary:")
    steps = agent.logger.dump_steps()
    for step in steps[-5:]:  # Show last 5 steps
        print(f"   {step}")

if __name__ == "__main__":
    asyncio.run(main())